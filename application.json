[
    {
        "id" : 1,
        "question" : "Two Sum",
        "levels" : "Easy",
        "tools" : "Dictionary",
        "algorithm" : ["Create a dictionary to store the element as the key and the index as the value.",
        "Use a for loop to run every element.",
        "If the target - the element is not in the dictionary, store the element and its index in the dictionary.",
        "Otherwise, return the index of (target-element) and the index.",
        "Write return null outside the for loop."],
        "complexity" : "O(n)",
        "detail" : ["Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
        "",
        "You may assume that each input would have exactly one solution, and you may not use the same element twice.",
        "",
        "You can return the answer in any order."],
        "input" : "nums = [2,7,11,15], target = 9",
        "output" : "[0, 1]",
        "youtube" : "https://youtu.be/oadssnyJA90"
    },
    {
        "id" : 2,
        "question" : "Valid Parentheses",
        "levels" : "Easy",
        "tools" : "Dictionary, Stack",
        "algorithm" : ["Left bracket -> put in the stack.",
        "Right bracket ->",
        "If the stack size is 0, return false.$",
        "If the stack value is equal to the dictionary value, pop it.$",
        "Else, return false.$",
        "If the stack is empty after we use the for loop to scan the string, return true. Otherwise, return false."],
        "complexity" : "O(n)",
        "detail" : ["Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
        "",
        "An input string is valid if:",
        "● Open brackets must be closed by the same type of brackets.",
        "● Open brackets must be closed in the correct order.",
        "● Every close bracket has a corresponding open bracket of the same type."],
        "input" : "s = '(]'",
        "output" : "false",
        "youtube" : "https://www.youtube.com/watch?v=WTzjTskDFMg"
    },
    {
        "id" : 3,
        "question" : "Merge Two Sorted Lists",
        "levels" : "Easy",
        "tools" : "Pointer",
        "algorithm" : ["Merge part of merge sort.",
        "Create ListNode result. Since the initial value of result.val is 0, we need to return result.next as the result.",
        "Create ListNode pointer to track the result and add elements to the result.",
        "Use a while loop with the condition that list1 and list2 are both not null.",
        "If list1.val < list2.val, set pointer.next = list1.val. Otherwise, set the pointer.next = list2.val.",
        "Set pointer = pointer.next.",
        "Outside the while loop. If list1 is not null, set tail.next = list1. Also, the same for list2.",
        "Return and submit the result.next."],
        "complexity" : "O(n)",
        "detail" : ["You are given the heads of two sorted linked lists list1 and list2.",
        "",
        "Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.",
        "",
        "Return the head of the merged linked list."],
        "input" : "list1 = [1,2,4], list2 = [1,3,4]",
        "output" : "[1,1,2,3,4,4]",
        "youtube" : "https://www.youtube.com/watch?v=XIdigk956u0"
    },
    {
        "id" : 4,
        "question" : "Best Time to Buy and Sell Stock",
        "levels" : "Easy",
        "tools" : "Pointer",
        "algorithm" : ["Set 2 pointers, buy and sell, for scanning the value of the int array and profit for the final result.",
        "For buy and profit, set value = 0. For the sell, use a for loop to go through the array.",
        "If (sell - buy) is negative, then we can buy the cheaper price and set the sell value to buy. Otherwise, update the max profit.",
        "The sell pointer starts from 1 and it's basically the for-loop index since we need to go through the loop.※",
        "The buy point starts from 0 since the first day is possible to be the lowest value.※"],
        "complexity" : "O(n)",
        "detail" : ["You are given an array prices where prices[i] is the price of a given stock on the ith day.",
        "",
        "You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
        "",
        "Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0."],
        "input" : "prices = [7,1,5,3,6,4]",
        "output" : "5",
        "youtube" : "https://www.youtube.com/watch?v=1pkOgXD63yU&t=349s"
    },
    {
        "id" : 5,
        "question" : "Valid Palindrome",
        "levels" : "Easy",
        "tools" : "Pointer",
        "algorithm" : ["Set s to lowercase and set back to s.",
        "Set the left pointer, from the start, and the right pointer, from the end.",
        "Use a while loop with condition left < right.",
        "Set a helper function with a boolean return type to check if the char is valid. Return true if the char is a number or an alphabet, return false otherwise.",
        "Set 2 nested while loop with condition true for both left and right to find a valid character.",
        "Inside the nested while loops：",
        "Return true if left or right out of bound.$",
        "Break the loop if the char is valid.$",
        "Else left++ or right--.$",
        "Compare s[left] and s[right], return false if they are not equal.",
        "Write left++ and right-- before the next outer loop.",
        "Return and submit true outside the outer while loop."],
        "complexity" : "O(n)",
        "detail" : ["A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.", "Alphanumeric characters include letters and numbers.",
        "",
        "Given a string s, return true if it is a palindrome, or false otherwise."],
        "input" : "s = 'race a car'",
        "output" : "false",
        "youtube" : "https://www.youtube.com/watch?v=XdMau9kwUvU"
    },
    {
        "id" : 6,
        "question" : "Invert Binary Tree",
        "levels" : "Easy",
        "tools" : "Recursion, DFS",
        "algorithm" : ["Base, if the root node is null then return null.",
        "Swap left and right nodes (If they are null, then 2 null nodes swap).",
        "Recursively doing this to the left node and the right node. Return root at the end."],
        "complexity" : "O(n).",
        "detail" : ["Given the root of a binary tree, invert the tree, and return its root."],
        "input" : "root = [4,2,7,1,3,6,9]",
        "output" : "[4,7,2,9,6,3,1]",
        "youtube" : "https://www.youtube.com/watch?v=OnSn2XEQ4MY"
    },
    {
        "id" : 7,
        "question" : "Valid Anagram",
        "levels" : "Easy",
        "tools" : "Dictionary or Array",
        "algorithm" : ["========== Dictionary Approach ==========",
        "Check if 2 strings have the same length, return false if not.",
        "First, use one for loop to save all the characters in the string s as the key and the frequency of each character as the value.",
        "Next, use the other for loop to run the string t.",
        "Return false if the key is not in the dictionary or the value becomes negative.",
        "Otherwise, decrease the dictionary value by 1.",
        "Put return true outside the second for loop since 2 strings will be Valid Anagram if their string length is the same and none of the characters have a negative frequency value.",
        "========== Array Approach ==========",
        "Check if 2 strings have the same length, return false if not.",
        "Create an array with 26 chunks.",
        "Use a for loop to add 1 for all the characters in the string s and minus 1 for all the characters in the string t.",
        "Write the other for loop to check if every chunk is 0. Return false if not.",
        "Return true outside the second loop.",
        "To put an alphabet into the correct array chunk, use the character - 'a' to count the corresponding index chunk.※"],
        "complexity" : "O(n)",
        "detail" : ["Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
        "",
        "An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once."],
        "input" : "s = 'anagram', t = 'nagaram'",
        "output" : "true",
        "youtube" : "https://www.youtube.com/watch?v=IRN1VcA8CGc"
    },
    {
        "id" : 8,
        "question" : "Binary Search",
        "levels" : "Easy",
        "tools" : "Pointer",
        "algorithm" : ["Create a left pointer and a right pointer to represent the array's start and end.",
        "Use a while loop if the left pointer is smaller than the right pointer.",
        "Start from the middle and compare the values.",
        "If the middle value is smaller than the target value, then get rid of the left part of the array, and vice versa.",
        "Return the index if target value = array value or return -1 outside the while loop."],
        "complexity" : "O(logn)",
        "detail" : ["Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.",
        "",
        "You must write an algorithm with O(log n) runtime complexity."],
        "input" : "nums = [-1,0,3,5,9,12], target = 9",
        "output" : "4",
        "youtube" : "https://www.youtube.com/watch?v=s4DPM8ct1pI"
    },
    {
        "id" : 9,
        "question" : "Flood Fill",
        "levels" : "Easy",
        "tools" : "Recursion, DFS",
        "algorithm" : ["Return the image directly if the color is the same as the starting pixel.",
        "Write a helper function dfs. If the position is out of bounds, write return. Moreover, if the value is not the starting pixel, write return. (Only change the same color).",
        "Change the color and make 4 recursive calls for 4 different directions.",
        "Call the helper function dfs and put all parameters inside. Not only are the parameters in the question, but we also need to add row, column, and source.",
        "Return and submit the image after the helper function."],
        "complexity" : "O(m * n).",
        "detail" : ["An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.",
        "",
        "You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].",
        "",
        "To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.",
        "",
        "Return the modified image after performing the flood fill."],
        "input" : "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2",
        "output" : "[[2,2,2],[2,2,0],[2,0,1]]",
        "youtube" : "https://www.youtube.com/watch?v=RwozX--B_Xs"
    },
    {
        "id" : 10,
        "question" : "Lowest Common Ancestor of a Binary Search Tree",
        "levels" : "Easy",
        "tools" : "Recursion, List",
        "algorithm" : ["Since the constraint states p and q will exist in BST, the LCA will exist for sure.",
        "Use 2 lists to store the path of p and q using recursive calls.",
        "Set the shorter length as the length for the for loop later.",
        "Use one for loop to compare the value of 2 lists to get the LCA.",
        "YouTube has the other approach.※"],
        "complexity" : "O(logn)",
        "detail" : ["Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.",
        "",
        "According to the definition of LCA on Wikipedia: 'The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).'"],
        "input" : "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
        "output" : "6",
        "youtube" : "https://www.youtube.com/watch?v=KobQcxdaZKY"
    },
    {
        "id" : 11,
        "question" : "Balanced Binary Tree",
        "levels" : "Easy",
        "tools" : "Recursion, DFS",
        "algorithm" : ["Write an unbalanced attribute = -1 to indicate the subtree is an unbalanced tree.",
        "Return true if the root is null.",
        "Create a helper function dfs with int return type and TreeNode node as a parameter to traverse the tree recursively.",
        "If both the left node and the right node are null, return 1.",
        "To get the left height, write a leftH variable = 0 and call dfs(node.left) if the left node is not null.",
        "If the left node is unbalanced, then return unbalanced.",
        "To get the right height, write a rightH variable = 0 and call dfs(node.right) if the right node is not null.",
        "If the right node is unbalanced, then return unbalanced.",
        "Check if the Math.abs(leftH - rightH) <= 1. Return Math.max(leftH, rightH) + 1 if the condition is true or return unbalance under the if statement.",
        "Return the helper function dfs(root) != unbalance. We will get true if the tree is not unbalanced or false if the tree is unbalanced."],
        "complexity" : "O(n).",
        "detail" : ["Given a binary tree, determine if it is height-balanced."],
        "input" : "root = [3,9,20,null,null,15,7]",
        "output" : "true",
        "youtube" : "https://www.youtube.com/watch?v=hpfEHXK_lOc"
    },
    {
        "id" : 12,
        "question" : "Linked List Cycle",
        "levels" : "Easy",
        "tools" : "Dictionary",
        "algorithm" : ["Create a dictionary with key = address and value = anything other than null.",
        "Use a while loop to go through every node with the condition head != null.",
        "Check the dictionary. Add the address to the dictionary if the address is not inside the dictionary. Or return true otherwise.",
        "Write return false outside the while loop."],
        "complexity" : "O(n)",
        "detail" : ["Given head, the head of a linked list, determine if the linked list has a cycle in it.",
        "",
        "There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.",
        "",
        "Return true if there is a cycle in the linked list. Otherwise, return false."],
        "input" : "head = [3,2,0,-4], pos = 1",
        "output" : "true",
        "youtube" : "https://www.youtube.com/watch?v=gBTe7lFR3vc"
    },
    {
        "id" : 13,
        "question" : "Implement Queue using Stacks",
        "levels" : "Easy",
        "tools" : "Stack",
        "algorithm" : ["Create 2 list attributes, stack, and temp.",
        "Initialize the 2 lists in the constructor.",
        "push() ->※",
        "Add x into the stack.$",
        "pop() ->※",
        "Use a while loop to pop all elements from the stack to the temp.$",
        "Then pop the temp and store it to answer the variable.$",
        "Use the other while loop to pop all elements from the temp to the stack.$",
        "Return answer.$",
        "peak() ->※",
        "Use a while loop to pop all elements from the stack to the temp.$ ",
        "Then get the last element of the temp and store it to answer the variable.$",
        "Use the other while loop to pop all elements from the temp to the stack.$",
        "Return answer.$",
        "empty() ->※",
        "Return true if the size of stack1 is 0 or return false otherwise."],
        "complexity" : "O(1) or O(n)",
        "detail" : ["Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).",
        "",
        "Implement the MyQueue class:",
        "",
        ["void push(int x) Pushes element x to the back of the queue.",
        "int pop() Removes the element from the front of the queue and returns it.",
        "int peek() Returns the element at the front of the queue.",
        "boolean empty() Returns true if the queue is empty, false otherwise."]],
        "input" : [["MyQueue", "push", "push", "peek", "pop", "empty"],
            [[], [1], [2], [], [], []]],
        "output" : "[null, null, null, 1, 1, false]",
        "youtube" : "https://www.youtube.com/watch?v=RzT6YgrGTyg"
    },
    {
        "id" : 14,
        "question" : "First Bad Version",
        "levels" : "Easy",
        "tools" : "Pointer, Binary Search",
        "algorithm" : ["To find the first bad version, go through a binary search. The lower pointer will point to the first bad version after the binary search.※",
        "Set 2 pointers, low and high, for binary search.",
        "Use a while loop to run a binary search with the condition low <= high.",
        "Calculate the min pointer with low + (high-low) / 2.",
        "If min is a bad version, then high = min - 1. Otherwise, low = min + 1.",
        "Return and submit the pointer low."],
        "complexity" : "O(logn).",
        "detail" : ["You are a product manager and currently leading a team to develop a new product.", "Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.",
        "",
        "Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.",
        "",
        "You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."],
        "input" : "n = 5, bad = 4",
        "output" : "4",
        "youtube" : "https://youtu.be/SiDMFIMldgg"
    },
    {
        "id" : 15,
        "question" : "Ransom Note",
        "levels" : "Easy",
        "tools" : "Dictionary",
        "algorithm" : ["Write the first loop to pair all characters with their frequency in the “magazine” string.",
        "And the second loop is to run -1 frequency for all characters in “ransonNote” string.",
        "If the character frequency becomes a negative number or the character does not exist in the dictionary, then return false.",
        "Otherwise, return true after the second loop finishes.",
        "Return false directly if the length of ransonNote is greater than magazine※"],
        "complexity" : "O(n).",
        "detail" : ["Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.",
        "",
        "Each letter in magazine can only be used once in ransomNote."],
        "input" : "ransomNote = 'a', magazine = 'b'",
        "output" : "false",
        "youtube" : "https://www.youtube.com/watch?v=k7L7YM-stsU"
    },
    {
        "id" : 16,
        "question" : "Climbing Stairs",
        "levels" : "Easy",
        "tools" : "For Loop, Fibonacci, Dynamic Programming",
        "algorithm" : ["The question says we can climb 1 or 2 steps each time, which means the number of ways to reach the current step is the sum of the previous 1 step and the previous 2 steps.",
        "Create an array with length = n+1 and use a for loop to achieve a dynamic programming approach.",
        "The base case 0 and 1 is = 1 because only 1 way can reach 0 and 1 step.",
        "Others are the sum of the previous step and the previous 2 steps.",
        "Return and submit array[n], which is the last element of the array."],
        "complexity" : "O(n)",
        "detail" : ["You are climbing a staircase. It takes n steps to reach the top.",
        "",
        "Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?"],
        "input" : "n = 2",
        "output" : "2",
        "youtube" : "https://www.youtube.com/watch?v=in3Fpx8-eOY"
    },
    {
        "id" : 17,
        "question" : "Longest Palindrome",
        "levels" : "Easy",
        "tools" : "DAT (U = 128)",
        "algorithm" : ["Create an array with U = 128.",
        "Use a for loop to run string s and count each char into DAT.",
        "Implement the other for loop to run DAT with the formula 'arr[i]/2 * 2' to sum all the pairs in a variable.",
        "If the result is < s.lengh, return result + 1. Otherwise, return the result directly."],
        "complexity" : "O(n)",
        "detail" : ["Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.",
        "",
        "Letters are case sensitive, for example,'Aa' is not considered a palindrome here."],
        "input" : "s = 'abccccdd'",
        "output" : "7",
        "youtube" : "https://www.youtube.com/watch?v=gWIRxxQZRrI"
    },
    {
        "id" : 18,
        "question" : "Reverse Linked List",
        "levels" : "Easy",
        "tools" : "Pointer, While loop",
        "algorithm" : ["To build a linked list from the end, we need to have:",
        "A head pointer to loop from the front (Get from the question).$",
        "A result pointer to build a linked list from the end.$",
        "A temp pointer to mark where the current position is.$",
        "Write a while loop with the condition head != null.",
        "Inside the loop:",
        "Point the temp pointer to head.next. (temp = 2-3-4-5-null)$",
        "Point head.next to the result. (head = 1-null, where null is the result pointer)$",
        "Move the result pointer to the head pointer. (head and result = 1-null)$",
        "Move the head pointer point back to temp. (head and temp = 2-3-4-5-null)$",
        "Return and submit the result pointer outside the loop."],
        "complexity" : "O(n)",
        "detail" : ["Given the head of a singly linked list, reverse the list, and return the reversed list."],
        "input" : "head = [1,2,3,4,5]",
        "output" : "[5,4,3,2,1]",
        "youtube" : "https://www.youtube.com/watch?v=G0_I-ZF0S38"
    },
    {
        "id" : 19,
        "question" : "Majority Element",
        "levels" : "Easy",
        "tools" : "Two Variables: the result & the count, For Each Loop",
        "algorithm" : ["Initialize the result and the count to 0.",
        "Use a for each loop to run every element.",
        "Inside the for each loop:",
        "Change the result to the element if the count equals 0.$",
        "If the result equals the element, then count += 1.$",
        "Else, count -= 1.$",
        "Finally, return n outside the for each loop."],
        "complexity" : "O(n)",
        "detail" : ["Given an array nums of size n, return the majority element.",
        "",
        "The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array."],
        "input" : "nums = [2,2,1,1,1,2,2]",
        "output" : "2",
        "youtube" : "https://youtu.be/7pnhv842keE"
    },
    {
        "id" : 20,
        "question" : "Add Binary",
        "levels" : "Easy",
        "tools" : "Pointer, While Loop, Reverse String Character Skill",
        "algorithm" : ["We need to have 5 variables:",
        "A pointer p_a, which points to the end of the string a.$",
        "A pointer p_b, which points to the end of the string b.$",
        "An int sum with the value = 0.$",
        "An int carry with the value = 0.$",
        "An empty string result to store each digit of the result.$",
        "Write a while loop with the condition that p_a >= 0 or p_b >= 0.",
        "Inside the while loop:",
        "Set the sum to the carry.$",
        "The sum += ord(a[p_a]) - ord('0') if p_a >= 0.$",
        "The pointer p_a needs to be minus 1.$",
        "The sum += ord(a[p_b]) - ord('0') if p_b >= 0.$",
        "The pointer p_b needs to be minus 1.$",
        "If the sum is greater than 1, set the carry = 1. Otherwise, set the carry = 0.$",
        "The string result += sum%2.$",
        "Outside the while loop, the string result needs to append carry if carry is not 0.",
        "Return the reverse of the string result.",
        "Java StringBuilder can use .append() to append an int into an existing object; use .reverse() to reverse all characters, and use .toString() to change a StringBuilder object to String.※",
        "Python can use [::-1] to reverse a string. Moreover, we can use ord() to change a string to an ASCII ordinal number and use str to change an int to a string※"],
        "complexity" : "O(n)",
        "detail" : ["Given two binary strings a and b, return their sum as a binary string."],
        "input" : "a = '11', b = '1'",
        "output" : "'100'",
        "youtube" : "https://youtu.be/keuWJ47xG8g"
    },
    {
        "id" : 21,
        "question" : "Diameter of Binary Tree",
        "levels" : "Easy",
        "tools" : "Recursive, Global Variable, Class Attributes",
        "algorithm" : ["Make a result attribute to count the max diameter when traversing the BST.",
        "Write dfs() function to traverse the BST.",
        "Inside the dfs() function:",
        "If the node is null, return -1. (Set no node to -1 to make the calculation easier)$",
        "Recursively call dfs(node.left) and save the return value to the left variable.$",
        "Recursively call dfs(node.right) and save the return value to the right variable.$",
        "Calculate the diameter variable by left + right + 2. (Because 2 more arrows when traversing from left to right)$",
        "Update the result attribute if the diameter is greater than the original result value.$",
        "Return the height by 1 + the maximum of the left or the right.$",
        "Call dfs() function, then return the result attribute."],
        "complexity" : "O(n).",
        "detail" : ["Given the root of a binary tree, return the length of the diameter of the tree.",
        "",
        "The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.",
        "",
        "The length of a path between two nodes is represented by the number of edges between them."],
        "input" : "root = [1,2,3,4,5]",
        "output" : "3",
        "youtube" : "https://www.youtube.com/watch?v=bkxqA8Rfv04"
    },
    {
        "id" : 22,
        "question" : "Middle of the Linked List",
        "levels" : "Easy",
        "tools" : "Pointers",
        "algorithm" : ["Create 2 pointers slow and fast and initialize them to the head node.",
        "Write a while loop with the condition that both fast and fast.next is not null.",
        "Move the slow pointer to the next.",
        "Then move the fast pointer to the next.next.",
        "Return slow pointer after the while loop."],
        "complexity" : "O(n)",
        "detail" : ["Given the head of a singly linked list, return the middle node of the linked list.",
        "",
        "If there are two middle nodes, return the second middle node."],
        "input" : "head = [1,2,3,4,5]",
        "output" : "[3,4,5]",
        "youtube" : "https://www.youtube.com/watch?v=A2_ldqM4QcY"
    },
    {
        "id" : 23,
        "question" : "Maximum Depth of Binary Tree",
        "levels" : "Easy",
        "tools" : "Recursion, DFS",
        "algorithm" : ["If the root is null, return 0.",
        "Recursively call maxDepth(root.left) and save the return value to the left variable.",
        "Recursively call maxDepth(root.right) and save the return value to the right variable.",
        "Return 1 + the maximum of the left or the right."],
        "complexity" : "O(n)",
        "detail" : ["Given the root of a binary tree, return its maximum depth.",
        "",
        "A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node."],
        "input" : "root = [3,9,20,null,null,15,7]",
        "output" : "3",
        "youtube" : "https://www.youtube.com/watch?v=hTM3phVI6YQ"
    },
    {
        "id" : 24,
        "question" : "Contains Duplicate",
        "levels" : "Easy",
        "tools" : "Dictionary or Set",
        "algorithm" : ["Create a dictionary or a set for checking duplicates.",
        "Use a for loop to run every single element.",
        "Return true if the element has already existed in the dictionary or the set.",
        "Otherwise, put the value in the dictionary or the set.",
        "Return false outside the for loop."],
        "complexity" : "O(n).",
        "detail" : ["Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct."],
        "input" : "nums = [1,2,3,1]",
        "output" : "true",
        "youtube" : "https://www.youtube.com/watch?v=3OamzN90kPg"
    },
    {
        "id" : 25,
        "question" : "Maximum Subarray",
        "levels" : "Medium",
        "tools" : "Local Variable",
        "algorithm" : ["Declare 2 local variables, result and current, and set the first element value to both of them.",
        "Write a for loop starting from the second element to go through the rest of the array.",
        "Update the current by finding the maximum between the current and the current + the element.",
        "Update the result by finding the maximum between the result and the current.",
        "Return the result outside the for loop.",
        "If the current is smaller, then choosing to include all the previous elements is greater. Otherwise, getting rid of the previous elements is greater.※"],
        "complexity" : "O(n)",
        "detail" : ["Given an integer array nums, find the subarray with the largest sum, and return its sum."],
        "input" : "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output" : "6",
        "youtube" : "https://www.youtube.com/watch?v=5WZl3MMT0Eg"
    },
    {
        "id" : 26,
        "question" : "Insert Interval",
        "levels" : "Medium",
        "tools" : "For Each Loop",
        "algorithm" : ["Create an ArrayList<int[]> to store a list of intervals.",
        "Use a for each loop to loop every element from the intervals array.",
        "Inside the for each loop, we need to write 3 conditions:",
        "If the element’s tail is smaller than the newInterval’s head, add the element to the ArrayList. (Insert the left-hand side interval)$",
        "If the element’s head is greater than the newInterval’s tail, add the newInterval to the ArrayList and set the element’s value to the newInterval. (Insert the left-hand side interval and point the newInterval to the next one)$",
        "Otherwise, merge the 2 intervals since they are overlapping. Set the min of 2 heads as the newInterval’s head and the max of 2 tails as the newInterval’s tail.$",
        "Outside the for each loop, add the newInterval to the ArrayList. (The last element)",
        "Change the ArrayList to an int[][] array by calling ArrayList.toArray(new int[.size()][]) and return it."],
        "complexity" : "O(n)",
        "detail" : ["You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.",
        "",
        "Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).",
        "",
        "Return intervals after the insertion."],
        "input" : "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output" : "[[1,5],[6,9]]",
        "youtube" : "https://youtu.be/A8NUOmlwOlM"
    },
    {
        "id" : 27,
        "question" : "01 Matrix",
        "levels" : "Medium",
        "tools" : "Nested For Loop",
        "algorithm" : ["Create the maximum distance = (row-1) + (column-1) or Integer.MAX_VALUE.",
        "Use 2 nested for loop.",
        "The first one goes through the loop from 0 toward the end and checks the value of up and left.$",
        "While the other one goes through the loop from the end back to 0 and checks the value of down and right.$",
        "If the value = 0, ignore and continue it.",
        "Check if each of the 4 directions is the wall. Set the adjacent value + 1 if the slot itself is not the wall. Otherwise, set the value to the maximum distance.",
        "At the end of each loop, set the minimum of each direction as the final value of the slot.",
        "Return the result matrix after 2 nested for loop.",
        "The algorithm is finding 0 first, then +1 from 0 toward every cell in 4 directions.※"],
        "complexity" : "O(n^2)",
        "detail" : ["Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.",
        "",
        "The distance between two adjacent cells is 1."],
        "input" : "mat = [[0,0,0],[0,1,0],[0,0,0]]",
        "output" : "[[0,0,0],[0,1,0],[0,0,0]]",
        "youtube" : "https://www.youtube.com/watch?v=uWxcgftKF-o"
    },
    {
        "id" : 28,
        "question" : "K Closest Points to Origin",
        "levels" : "Medium",
        "tools" : "Sorting 2D Array",
        "algorithm" : ["Since we don’t need to get the distance value, we don’t need to calculate the square root. Instead, we can simply compare (x^2) + (y^2) as the distance.",
        "Use one for loop to calculate the distance and store [distance, x, y] into a new 2D array.",
        "Using built-in functions to sort the new array based on the distance, the first element of the array.",
        "Pick the first K closest element and store their x and y into the result array.",
        "※Sort the first element※",
        "Python -> arr.sort(key = lambda i : i[0])※",
        "Java -> Arrays.sort( arr, Comparator.comparingInt(a -> a[0]) );※"],
        "complexity" : "O(n + nlogn)",
        "detail" : ["Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).",
        "",
        "The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2).",
        "",
        "You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in)."],
        "input" : "points = [[1,3],[-2,2]], k = 1",
        "output" : "[[-2,2]]",
        "youtube" : "https://youtu.be/rI2EBUEMfTk"
    },
    {
        "id" : 29,
        "question" : "Longest Substring Without Repeating Characters",
        "levels" : "Medium",
        "tools" : "2 Pointers, Set",
        "algorithm" : ["Declare a set to store characters, an int left pointer, and an int max.",
        "Next, create a right pointer as an index in a for loop to go through every character of the string s.",
        "Inside the for loop, use a while loop to pop the first element of the list if the list contains the character that the for loop is pointing at.",
        "The left pointer needs to +1 whenever we remove an element from the list in the while loop.",
        "Outside the while loop, add the character into the set.",
        "Assign the max value by checking the value between the max and (right - left + 1).",
        "Return result outside for loop.",
        "※Using 2 pointers and a set is the way to check if a string contains a specific char※",
        "Python -> in",
        "Java -> Array.contains()"],
        "complexity" : "O(n)",
        "detail" : ["Given a string s, find the length of the longest substring without repeating characters."],
        "input" : "s = 'abcabcbb'",
        "output" : "3",
        "youtube" : "https://youtu.be/wiGpQwVHdE0"
    },
    {
        "id" : 30,
        "question" : "3Sum",
        "levels" : "Medium",
        "tools" : "For loop and if statements",
        "algorithm" : ["Sort the input array.",
        "Use a for loop to iterate through the array.",
        "Inside the for loop:",
        "If i > 0 and nums[i] == nums[i-1], write continue.$",
        "Set the left pointer to i+1 and the right pointer to the last index of the nums.$",
        "Write a while loop inside the for loop to find the 3sum solution.$",
        "Inside the while loop:",
        "Set the sum = nums[i] + nums[left] + nums[right] and check the sum.$",
        "If the sum is greater than 0, right--.$",
        "If the sum is smaller than 0, left++.$",
        "If the sum is 0, store 3 values in the result and move the left pointer to the next different value.$",
        "Return result outside the for loop.",
        "The idea is to use a for loop to fix one element, and then use a while loop to loop the left pointer and the right pointer to find the 3sum solutions.※"],
        "complexity" : "O(n^2)",
        "detail" : ["Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
        "",
        "Notice that the solution set must not contain duplicate triplets."],
        "input" : "nums = [-1,0,1,2,-1,-4]",
        "output" : "[[-1,-1,2],[-1,0,1]]",
        "youtube" : "https://youtu.be/jzZsG8n2R9A"
    },
    {
        "id" : 31,
        "question" : "Binary Tree Level Order Traversal",
        "levels" : "Medium",
        "tools" : "BFS, queue, 2D List",
        "algorithm" : ["Use BFS to traverse the tree and have lists for each level.",
        "At each level, put all elements (left to right) into the queue and when popping it, add it to the list. When the queue is empty, the list for that level is done.",
        "Repeat the previous step until no children are left (queue should be empty).",
        "Combine the lists into one list."],
        "complexity" : "O(n)",
        "detail" : ["Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level)."],
        "input" : "root = [3,9,20,null,null,15,7]",
        "output" : "[[3],[9,20],[15,7]]",
        "youtube" : "https://youtu.be/6ZnyEApgFYg"
    },
    {
        "id" : 32,
        "question" : "Clone Graph",
        "levels" : "Medium",
        "tools" : "Dictionary, DFS, Recursion",
        "algorithm" : ["Create a HashMap to pair the old node and the new node.",
        "Make a function called dfs to traverse every node and clone it.",
        "Inside the function, check the HashMap if the node has been cloned, return cloned node if the HashMap has the cloned one.", 
        "Outside the if statement, make a copy for the node and store it into the HashMap.",
        "Use for loop to run every single neighbor nodes of the node and call dfs function to append them into cloned node.",
        "Return copy outside the for loop for appending copy if it didn't exist in HashMap.",
        "Before calling return dfs(node) for submitting the answer, we need to check if the original node is None. Return None if the original node has nothing."],
        "complexity" : "O(n). Traverse every node.",
        "detail" : ["Given a reference of a node in a connected undirected graph.",
        "",
        "Return a deep copy (clone) of the graph.",
        "",
        "Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors."],
        "input" : "adjList = [[2,4],[1,3],[2,4],[1,3]]",
        "output" : "[[2,4],[1,3],[2,4],[1,3]]",
        "youtube" : "https://youtu.be/mQeF6bN8hMk"
    },
    {
        "id" : 33,
        "question" : "Evaluate Reverse Polish Notation",
        "levels" : "Medium",
        "tools" : "Stack (Using a list)",
        "algorithm" : ["Create a list for storing data. Making a for loop to run every char in token.",
        "Since the char only '+', '-', '*', '/' and 10 digits, we just need to if-else or switch-case to check every possible cases inside the for loop.",
        "Because the order doesn't matter for addition and multiplication, we can simply pop 2 numbers, do the calculation, and append the result into the stack for '+' and '*'.",
        "The order needs to be reverse for subtraction and division. Thus, we need to pop twice from the stack and store the value to two local variable, then do the calculation and append the result to stack.",
        "For all digits, we just need to simply convert char to int and append them to stack.",
        "Restun the first element of the stack for submitting the answer."],
        "complexity" : "O(n)",
        "detail" : ["You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.",
        "",
        "Evaluate the expression. Return an integer that represents the value of the expression."],
        "input" : "tokens = ['2','1','+','3','*']",
        "output" : "9",
        "youtube" : "https://youtu.be/iu0082c4HDE"
    },
    {
        "id" : 34,
        "question" : "Course Schedule",
        "levels" : "Medium",
        "tools" : "DFS, Recursion, Dictionary, Adjacency List",
        "algorithm" : ["Create a HashMap with key from 0 to n-1 and their own list as value.",
        "Use one for loop to put all course prerequisites into corresponding course.",
        "Make a list or set to store Visited Course List to check if the graph has a loop inside.",
        "Write a function called dfs to traverse every node inside the graph.",
        "Check if the course is inside Visited Course List, return false if the course is inside.",
        "Using the key to check the HashMap. Return true if the value is an empty list.",
        "Add the course to Visited Course List.",
        "Make a for loop to run every prerequisites of the course and make a recursive call to run every single prerequisites of the course. Return false directly if any of them return false.",
        "Remove the course from Visited Course List.",
        "Reset the value of the course to empty list. So, the some course won't need to recheck its prerequisites again.",
        "Return true in the end.",
        "To call and submit the answer, we need to make a for loop to call every course using dfs function to avoid any of the course is not in the same graph."],
        "complexity" : "O(n + p)\\n※p stands for the number of prerequisites of the course※",
        "detail" : ["There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.",
        "",
        "For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.",
        "Return true if you can finish all courses. Otherwise, return false."],
        "input" : "numCourses = 2, prerequisites = [[1,0]]",
        "output" : "true",
        "youtube" : "https://youtu.be/EgI5nU9etnU"
    },
    {
        "id" : 35,
        "question" : "Implement Trie (Prefix Tree)",
        "levels" : "Medium",
        "tools" : "Linked Dictionary, Prefix Tree",
        "algorithm" : ["Create a TrieNode class that contains a HashMap and a boolean attributes.",
        "For every function ->",
        "Set root as current node.",
        "Use one for loop to go through every char of the string.",
        "If the HashMap has no char ->",
        ["Return false for search and startsWith functions.",
        "Insert the char as the key and create the other TrieNode as the value into HashMap attribute."],
        "Move current node to the child node by setting current node to HashMap value.",
        "Outside for loop ->",
        ["insert() -> set the boolean attribute to true.",
        "search() -> return the boolean attribute.",
        "startsWith() -> return true."]],
        "complexity" : "O(n). For each function.\\n※n = the number of char in the string※",
        "detail" : ["A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.",
        "",
        "Implement the Trie class:",
        "",
        ["Trie() Initializes the trie object.",
        "void insert(String word) Inserts the string word into the trie.",
        "boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.",
        "boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise."]],
        "input" : [["Trie", "insert", "search", "search", "startsWith", "insert", "search"],
            [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]],
        "output" : "[null, null, true, false, true, null, true]",
        "youtube" : "https://youtu.be/oobqoCJlHA0"
    },
    {
        "id" : 36,
        "question" : "Coin Change",
        "levels" : "Medium",
        "tools" : "Dynamic Programming (Storing Array), Nested Loop",
        "algorithm" : ["Create an array dp[] with size = amount + 1 and initialize amount + 1 as the value to every element. ※Setting amount + 1 as the value will be impossible value if the question has possible answer.※",
        "Set dp[0] = 0 as we don't need any coin to get 0.",
        "Write a nested loop that the range of outer loop is from 1 to amount, skipping index 0, and the inner loop is checking all possible coins.",
        "Inside the loop, set dp[index] = min(d[index], 1 + dp[index - coin]) if index - coin >= 0.",
        "Check if dp[amount] = initial value. Return -1 if dp[amount] is an initial value. Otherwise, return its value."],
        "complexity" : "O(amount * coins). Using nested loop.",
        "detail" : ["You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.",
        "",
        "Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
        "",
        "You may assume that you have an infinite number of each kind of coin."],
        "input" : "coins = [1,2,5], amount = 11",
        "output" : "3",
        "youtube" : "https://youtu.be/H9bfqozjoqs"
    },
    {
        "id" : 37,
        "question" : "Product of Array Except Self",
        "levels" : "Medium",
        "tools" : "Temp Local Variable, For Loop",
        "algorithm" : ["※The constraint is no division and run the solution in O(n) time※",
        "Create a result array with length of nums and initial values are 1.",
        "Prefix ->",
        ["Set local variable prefix = 1.",
        "Use a for loop to go through the result array forwardly.",
        "Inside for loop, set result[i] = prefix.",
        "Then, prefix *= nums[i]."],
        "Postfix ->",
        ["Set local variable postfix = 1.",
        "Use a for loop to go through the result array backwardly.",
        "Inside for loop, set result[i] *= postfix.",
        "Then, postfix *= nums[i]"],
        "Return and submit the result array."],
        "complexity" : "O(n)",
        "detail" : ["Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
        "",
        "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",
        "",
        "You must write an algorithm that runs in O(n) time and without using the division operation."],
        "input" : "nums = [1,2,3,4]",
        "output" : "[24,12,8,6]",
        "youtube" : "https://youtu.be/bNvIQI2wAjk"
    },
    {
        "id" : 38,
        "question" : "Min Stack",
        "levels" : "Medium",
        "tools" : "Stack (List)",
        "algorithm" : ["Create 2 stake to run all functions in O(1) time. One is stake of value and the other one is stake of min value.",
        "For pushing the value in min stake. Push the min between the new value and the top of min stake into min stake. No need to compare if the min stake is empty."],
        "complexity" : "O(1)",
        "detail" : ["Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
        "",
        "Implement the MinStack class:",
        "",
        ["MinStack() initializes the stack object.",
        "void push(int val) pushes the element val onto the stack.",
        "void pop() removes the element on the top of the stack.",
        "int top() gets the top element of the stack.",
        "int getMin() retrieves the minimum element in the stack."],
        "You must implement a solution with O(1) time complexity for each function."],
        "input" : [["MinStack","push","push","push","getMin","pop","top","getMin"],
            [[], [-2], [0], [-3], [], [], [], []]],
        "output" : "[null,null,null,null,-3,null,0,-2]",
        "youtube" : "https://youtu.be/qkLl7nAwDPo"
    },
    {
        "id" : 39,
        "question" : "Validate Binary Search Tree",
        "levels" : "Medium",
        "tools" : "Boundary Parameters, DFS, Recursion",
        "algorithm" : ["Create a recursive function dfs() that has node parameter for recursive call and left and right boundary parameters.",
        "If the node is null, leaf, return true.",
        "Return false if the node.value is not between left and right boundary because the node breaks BST.",
        "Recursively calling left child with node.value as right boundary.",
        "Recursively calling right child with node.value as left boundary.",
        "Return the value of (right child) and (left child).",
        "Return and submit dfs(root, max-int, min-int)"],
        "complexity" : "O(n). Visit once for each node.",
        "detail" : ["Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
        "",
        "A valid BST is defined as follows:",
        "",
        ["The left subtree of a node contains only nodes with keys less than the node's key.",
        "The right subtree of a node contains only nodes with keys greater than the node's key.",
        "Both the left and right subtrees must also be binary search trees."]],
        "input" : "root = [2,1,3]",
        "output" : "true",
        "youtube" : "https://youtu.be/s6ATEkipzow"
    },
    {
        "id" : 40,
        "question" : "Number of Islands",
        "levels" : "Medium",
        "tools" : "DFS, Recursion",
        "algorithm" : ["Set local variables row and column of grid and return 0 if both of them are 0.",
        "Declare local variable island = 0 for preparing to count.",
        "Use nested loop to go through row and column for traversing the grid.",
        "Inside the loop, make a recursive dfs call to mark the island to 2 and local variable island += 1 if the slot of the grid is an island.",
        "The recursive call has 5 parameters. ",
        ["The grid",
        "Current x position",
        "Current y position",
        "The row length of the grid",
        "The column length of the grid"],
        "Inside the recursive call, return nothing if the current position is out of bound or the value is not '1', not an island.",
        "Change the value from '1' to '2' indicates we have visited this slot.",
        "Make four recursive call for four directions."],
        "complexity" : "O(n)",
        "detail" : ["Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
        "",
        "An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water."],
        "input" : "grid = [  ['1','1','1','1','0'],  ['1','1','0','1','0'],  ['1','1','0','0','0'],  ['0','0','0','0','0']]",
        "output" : "1",
        "youtube" : "https://www.youtube.com/watch?v=__98uL6wst8"
    },
    {
        "id" : 41,
        "question" : "Rotting Oranges",
        "levels" : "Medium",
        "tools" : "BFS, Queue",
        "algorithm" : ["Create a class Rot that has 3 int attributes, time, x, and y.",
        "Write a list as a queue to store rot oranges.",
        "Make a local variable fresh for counting numbers of fresh oranges in the grid.",
        "Need to check if the grid is empty by checking row and column.",
        "Use a nested loop to run the grid and put rot oranges in the queue and count how many fresh in the grid.",
        "Create a local Rot called currRot for storing the final time.",
        "Use a while loop to dequeue the queue.",
        "Make a function called bfs with 8 attributes.",
        ["grid",
        "time",
        "x coordinate",
        "y coordinate",
        "row",
        "column",
        "queue",
        "fresh"],
        "Int bfs function, if the moved position is in the grid and its orange is a fresh orange, mark its orange as rot, enqueue the position to the queue with time + 1, and return fresh -= 1.",
        "Inside the while loop, dequeue the queue and store it to a local Rot variable currRot.",
        "Call bfs for four directions of currRot and store the return value to fresh.",
        "Outside while loop, return currRot.time if fresh == 0. Otherwise, return -1."],
        "complexity" : "O(n*m). Visites all slots of the grid.",
        "detail" : ["You are given an m x n grid where each cell can have one of three values:",
        "",
        ["0 representing an empty cell,",
        "1 representing a fresh orange, or",
        "2 representing a rotten orange."],
        "Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.",
        "",
        "Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1."],
        "input" : "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output" : "4",
        "youtube" : "https://youtu.be/y704fEOx0s0"
    },
    {
        "id" : 42,
        "question" : "Search in Rotated Sorted Array",
        "levels" : "Medium",
        "tools" : "Pointer, Binary Search",
        "algorithm" : ["Setting left and right pointers for Binary Search.",
        "Use while loop to run Binary Search, in which the condition is left <= right.",
        "Calculate the mid index by implementing (left + right) / 2.",
        "Return nums[mid] if it is the target value.",
        "To check the mid value is right or left portion, we need to compare the mid value with left value.",
        "If the mid value is in the left portion, the target will be in the left half:",
        ["If the target is smaller than mid value.",
        "If the target is bigger than the right value.",
        "Otherwise, the target is in the right half."],
        "If the mid value is in the right portion, the target will be in the right half: ",
        ["If the target is bigger than mid value.",
        "If the target is small than the right value.",
        "Otherwise, the target is in the left half."],
        "Return -1 outside the while loop since we cannot find the target in the nums."],
        "complexity" : "O(logn), Binary Search",
        "detail" : ["There is an integer array nums sorted in ascending order (with distinct values).",
        "",
        "Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].",
        "",
        "Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
        "",
        "You must write an algorithm with O(log n) runtime complexity."],
        "input" : "nums = [4,5,6,7,0,1,2], target = 0",
        "output" : "4",
        "youtube" : "https://youtu.be/U8XENwh8Oy8"
    },
    {
        "id" : 43,
        "question" : "Combination Sum",
        "levels" : "Medium",
        "tools" : "DFS, Recursion",
        "algorithm" : ["Create a result list to store the final result.",
        "Making a dfs() that pass:",
        ["pointer -> ※point to the current candidate",
        "current answer list",
        "total"],
        "Inside the dfs() function, append a copy of current answer list to result list if total is equal to target.",
        "If pointer = candidates.length or total is greater than target, return out from the recursive dfs() call.",
        "One brench is to append the current candidate into current answer list",
        "Make a recursive call that pointer stay the same and the total needs to be added with the candidate.",
        "Pop the current candidate from the current answer list in order to make the other brench of the recursion call.",
        "The pointer needs to be added by 1 in second recursion call to move to the next candidate.",
        "Call the dfs(0, list, 0) and return the result list as the final result."],
        "complexity" : "",
        "detail" : ["Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.",
        "",
        "The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.",
        "",
        "The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."],
        "input" : "candidates = [2,3,6,7], target = 7",
        "output" : "[[2,2,3],[7]]",
        "youtube" : "https://youtu.be/GBKI9VSKdGg"
    },
    {
        "id" : 44,
        "question" : "Permutations",
        "levels" : "Medium",
        "tools" : "Recursion",
        "algorithm" : ["Create a result for submitting the answer.",
        "The based case is that return the copy of nums if the length of nums is 1.",
        "Use the for loop to iterate list num.",
        "Inside the for loop, pop the first element and store it to local variable called item first.",
        "Make permute(nums) recursive call and store the return permutations to the other variable called per.",
        "Use the other for loop to append popped variable item into every permutations variable per.",
        "Outside the inner loop append all elements to the result list since variable per is defined in outer for loop.",
        "Append popped element item back to original nums.",
        "Return and submit result list."],
        "complexity" : "O(n!). Since we need to calculate the permutation and store the result for the answer.",
        "detail" : ["Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order."],
        "input" : "nums = [1,2,3]",
        "output" : "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "youtube" : "https://youtu.be/s7AvT7cGdSo"
    },
    {
        "id" : 45,
        "question" : "Merge Intervals",
        "levels" : "Medium",
        "tools" : "※Sort the first element\\nPython -> arr.sort(key = lambda i : i[0])\\nJava -> Arrays.sort( arr, Comparator.comparingInt(a -> a[0]) )",
        "algorithm" : ["We can return intervals directly if the intervals only has one interval or has no element inside.",
        "Sort the intervals elements by the starting points.",
        "Create an result ArrayList to store the final interval answers.",
        "Set the first interval as the current interval and put them into result.",
        "Use for loop to go through and check every elements of intervals.",
        "If the interval[index].end > current interval.start, which means two intervals overlap to each other, then the end is the max between interval[index] and current interval end.",
        "If the two interval has no overlap, then set the interval[index] as the current interval and add it to result ArrayList.",
        "Before submit the result ArrayList, we need to convert it to an array since the return type is an array instead of an ArrayList."],
        "complexity" : "O(nlogn). The algrithm contains sortting algrithm.",
        "detail" : ["Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input."],
        "input" : "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output" : "[[1,6],[8,10],[15,18]]",
        "youtube" : "https://www.youtube.com/watch?v=qKczfGUrFY4"
    },
    {
        "id" : 46,
        "question" : "Lowest Common Ancestor of a Binary Tree",
        "levels" : "Medium",
        "tools" : "Recursion, DFS",
        "algorithm" : ["Return root if root.val == p.val or root.val == q.val.",
        "Return null if root.left == null and root.right == null (The root is a leaf).",
        "Make two TreeNode objects to store the return value of the left child and the right child.",
        "If the left child is not null, recursively call the left child and store the return value to the left TreeNode object.",
        "If the right child is not null, recursively call the right child and store the return value to the right TreeNode object.",
        "Return root if both left and right are not null.",
        "Return left if left is not null. Otherwise, return right."],
        "complexity" : "O(n). Need to travers the whole tree.",
        "detail" : ["Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
        "",
        "According to the definition of LCA on Wikipedia: 'The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).'"],
        "input" : "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output" : "3",
        "youtube" : "https://www.youtube.com/watch?v=KobQcxdaZKY"
    },
    {
        "id" : 47,
        "question" : "Time Based Key-Value Store",
        "levels" : "Medium",
        "tools" : "Dictionary, Binary Search",
        "algorithm" : ["Initialize a dictionary attribue in the constructor where value is a list of an two elements array.",
        "In set function. Create a list object to key if key is not in the dictionary.",
        "Append the value and the time with the key into the dictionary.",
        "In get function. Create a result variable with empyt string since we need to return an empty string if the key is not exist in the dictionary.",
        "Find the value using key in the dictionary and store the value into a local variable. Return an empty list if key is not in the dictionary.",
        "Return and submit result after running Binary Search.",
        "Since the question return the largest timestamp, we need to reset the time stamp when we recursively call the right hand side of the timestamp in the dictionary."],
        "complexity" : "O(1) -> set()\\nO(logn) -> get()",
        "detail" : ["Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.",
        "",
        "Implement the TimeMap class:",
        "",
        ["TimeMap() Initializes the object of the data structure.",
        "void set(String key, String value, int timestamp) Stores the key key with the value value at the given time imestamp.",
        "String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If  there are no values, it returns ' '."]],
        "input" : [["TimeMap", "set", "get", "get", "set", "get", "get"],
            [[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]],
        "output" : "[null, null, 'bar', 'bar', null, 'bar2', 'bar2']",
        "youtube" : "https://youtu.be/fu2cD_6E8Hw"
    },
    {
        "id" : 48,
        "question" : "Accounts Merge",
        "levels" : "Medium",
        "tools" : "",
        "algorithm" : [],
        "complexity" : "",
        "detail" : ["Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.",
        "",
        "Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.",
        "",
        "After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order."],
        "input" : "accounts = [['John','johnsmith@mail.com','john_newyork@mail.com'],['John','johnsmith@mail.com','john00@mail.com'],['Mary','mary@mail.com'],['John','johnnybravo@mail.com']]",
        "output" : "[['John','john00@mail.com','john_newyork@mail.com','johnsmith@mail.com'],['Mary','mary@mail.com'],['John','johnnybravo@mail.com']]",
        "youtube" : "https://youtu.be/6st4IxEF-90"
    },
    {
        "id" : 49,
        "question" : "Sort Colors",
        "levels" : "Medium",
        "tools" : "Pointer",
        "algorithm" : ["※We can use partition to solve it using only one for loop since the question only has 3 possible numbers.※",
        "Create 3 pointers -> left, right, index to go through the entire array.",
        "Make a while loop with index <= right pointer as the condition.",
        "If the value = 0, swap index and left pointer then increment left pointer by 1.",
        "If the value = 2, swap index and right pointer then decrement both pointers by 1.",
        "Increment index by 1. (Cancel -1 when the value = 2)."],
        "complexity" : "O(n). Particularly, only use one for loop.",
        "detail" : ["Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.",
        "",
        "We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.",
        "",
        "You must solve this problem without using the library's sort function."],
        "input" : "nums = [2,0,2,1,1,0]",
        "output" : "[0,0,1,1,2,2]",
        "youtube" : "https://youtu.be/4xbWSRZHqac"
    },
    {
        "id" : 50,
        "question" : "Word Break",
        "levels" : "Medium",
        "tools" : "Dynamic Programming (Bottom Up Approach)",
        "algorithm" : ["Set a boolean list with length = s.length + 1 and inicialize all value to false.",
        "Change the last element to true since we need to return true if we can clear all characters using the words in the wordDict list.",
        "Use a nested loop to go through every char in s and every element of wordDict list.",
        "The outer loop needs to be iterated from the end toward to the start, while inner loop just loop each value of the element.",
        "Inside two loops, dp[index] = d[index + words.length] if s.substring(index, index + word.length). This means if the next few chars = words, we will check if the rest can be solved using wordDict list.",
        "If dp[index] = true, then we can break the inner loop because we have fond the way to slove from the current position until the end.",
        "Outside the outer loop, return the first index since it tells as if we can find the correct combination for the whole string using words in wordDict list."],
        "complexity" : "O(s * w). Nested loop.\\ns -> the number of characters in string s.\\nw -> the number of different words in the wordDict list.",
        "detail" : ["Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.",
        "",
        "Note that the same word in the dictionary may be reused multiple times in the segmentation."],
        "input" : "s = 'leetcode', wordDict = ['leet','code']",
        "output" : "true",
        "youtube" : "https://youtu.be/Sx9NNgInc3A"
    },
    {
        "id" : 51,
        "question" : "Partition Equal Subset Sum",
        "levels" : "Medium",
        "tools" : "Set",
        "algorithm" : ["Get the sum of nums and return false if the sum is an odd number. Otherwise, calculate the target number.",
        "Create a set with 0 inside.",
        "Make a nested for loop. Iterate nums in the outer loop and iterate the set in the inner loop.",
        "Create the temp set inside the outer loop and set the temp set to the original set outside the inner loop.",
        "Inside the inner loop, check and return true if we find the summed numbers are equal to the target value. Otherwise, add the summed numbers in the original set and the sum of the iterating value and the values in the original set in the temp set.",
        "Return false outside the nested loop."],
        "complexity" : "O( sum(nums) )",
        "detail" : ["Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise."],
        "input" : "nums = [1,5,11,5]",
        "output" : "true",
        "youtube" : "https://youtu.be/IsvocB5BJhw"
    },
    {
        "id" : 52,
        "question" : "String to Integer (atoi)",
        "levels" : "Medium",
        "tools" : "Long Variable, Boolean Variable, For Loop.",
        "algorithm" : ["Store all characters of s to a char array arr.",
        "Make a boolean check to indicate we only skip whitespace before hit any other characters.",
        "Declare a local variable sign to mark if the number is positive or negative.",
        "And use long instead of int to store the result value since we need to check if the final result is greater than the max of int or smaller than the min of int.",
        "Use a for loop to iterate every character of a string.",
        "If the char is a whitespace and check is false, which means it's a whitespace before any other char, continue the loop.",
        "Else, check if the first char after whitespace is a '+' or a '-'. Mark it to the local variable sign if it is. Then iterate variable i need to + i in order to keep checking the next char in the same loop. Break the loop if index out of bound or check is true.",
        "The other if statement in else block to check if the char is a numeral char that between '0' to '9'. Break the loop if it's not.",
        "If it is:",
        ["Make check = true.",
        "Variable result *= 10.",
        "Check the sign variable. Do arr[i] - '0' for positive numbers or ‘0' - arr[i] for negative numbers to result variable.",
        "Check if the result is greater than the max of int or if the result is smaller than the min of int. Return the max or min of int if the result is out of int bound."],
        "Change result to int and return it outside the for loop."],
        "complexity" : "O(n)",
        "detail" : ["Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).",
        "",
        "The algorithm for myAtoi(string s) is as follows:",
        "",
        ["Read in and ignore any leading whitespace.",
        "Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.",
        "Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.",
        "Convert these digits into an integer (i.e. '123' -> 123, '0032' -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).",
        "If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2^31 should be clamped to -2^31, and integers greater than 2^31 - 1 should be clamped to 2^31 - 1.",
        "Return the integer as the final result."]],
        "input" : "s = '42'",
        "output" : "42",
        "youtube" : "https://youtu.be/qxIprnPrVZA"
    },
    {
        "id" : 53,
        "question" : "Spiral Matrix",
        "levels" : "Medium",
        "tools" : "Pointer",
        "algorithm" : ["Make a result list to store the final answer.",
        "Create 4 pointers, left, right, top, and bottom, to indicate the 4 boundary of the matrix.",
        "Write a while loop with (left < right && top < bottom) as the condition.",
        "Run 4 for loops to add 4 boundaries into the result list in the while loop.",
        "Top row for loop, range from left to right with top += 1 outside the loop. Check the condition before running the next for loop.",
        "Right column for loop, range from top to bottom with right -= 1 outside the loop. Check the condition before running the next for loop.",
        "Bottom row for loop, range from right to left with bottom -= 1 outside the loop. Check the condition before running the next for loop.",
        "Left column for loop, range from bottom to top with left += 1 outside the loop.",
        "Return and submit the result list outside the while loop."],
        "complexity" : "O(m*n). Every element in the matrix.",
        "detail" : ["Given an m x n matrix, return all elements of the matrix in spiral order."],
        "input" : "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output" : "[1,2,3,6,9,8,7,4,5]",
        "youtube" : "https://youtu.be/BJnMZNwUk1M"
    },
    {
        "id" : 54,
        "question" : "Subsets",
        "levels" : "Medium",
        "tools" : "DFS, Decision Tree",
        "algorithm" : ["Declare result list and subset list.",
        "Make dfs() function to recursively call the function, which has i as the parameter to run iterate every element in the given list.",
        "Inside the dfs() function:",
        ["The base case is i = the length of given list. Copy the subset list to the result.",
        "For the decision including nums[i]. Append nums[i] to subset and call dfs(i+1).",
        "For the decision not including nums[i]. Pop nums[i] to subset and call dfs(i+1)."],
        "Make dfs(0) call and return result list."],
        "complexity" : "O(2^n)",
        "detail" : ["Given an integer array nums of unique elements, return all possible subsets (the power set).",
        "",
        "The solution set must not contain duplicate subsets. Return the solution in any order."],
        "input" : "nums = [1,2,3]",
        "output" : "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "youtube" : "https://youtu.be/REOH22Xwdkk"
    },
    {
        "id" : 55,
        "question" : "Binary Tree Right Side View",
        "levels" : "Medium",
        "tools" : "BFS, Recursion",
        "algorithm" : ["※Different from the YouTube solution※",
        "Create a result list.",
        "Make a bfs() function with node and level attributes to call it recursively.",
        "Inside bfs() function:",
        ["Return the function if the node is null.",
        "Add the node.val to the result list if level = the size of the result list.",
        "Recursively call the right child with level + 1.",
        "Recursively call the left child with level + 1."],
        "Return the result list."],
        "complexity" : "O(n)",
        "detail" : ["Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom."],
        "input" : "root = [1,2,3,null,5,null,4]",
        "output" : "[1,3,4]",
        "youtube" : "https://youtu.be/d4zLyf32e3I"
    },
    {
        "id" : 56,
        "question" : "Longest Palindromic Substring",
        "levels" : "Medium",
        "tools" : "Pointer",
        "algorithm" : ["Create an empty string result for final answer and an int size to help future check if the current palindromic is a longer palindromic.",
        "Use for loop to run every char in the string.",
        "To check odd palindromic, set both left and right pointers to i.",
        "Run the while loop if left and right pointers are both inbound and the char they represent are also the same.",
        "Inside the while loop, update result string and size if the length of current substring, right - left + 1, is greater than variable size.",
        "Then, update the left pointer by minus 1 and the right pointer by plus 1.",
        "To check even palindromic, do everything the same as odd palindromic but initicalize right pointer to i + 1.",
        "Return and submit result as the final answer."],
        "complexity" : "O(n^2)",
        "detail" : ["Given a string s, return the longest palindromic substring in s."],
        "input" : "s = 'babad'",
        "output" : "bab",
        "youtube" : "https://www.youtube.com/watch?v=XYQecbcd6_c&t=16s"
    },
    {
        "id" : 57,
        "question" : "Unique Paths",
        "levels" : "Medium",
        "tools" : "Dynamic Programming",
        "algorithm" : ["Create a m * n grid or a 2D list.",
        "Make a nested loop to run the grid.",
        "If either m or n is 0, then the value is 1, which indicates we only have one way to reach that slot.",
        "Otherwise, calculate the slot by adding the value of its top slot and the left slot.",
        "Return and submit the last slot of the grid."],
        "complexity" : "O(m * n). Create a grid and run each slot.",
        "detail" : ["There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.",
        "",
        "Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
        "",
        "The test cases are generated so that the answer will be less than or equal to 2 * 10^9."],
        "input" : "m = 3, n = 7",
        "output" : "28",
        "youtube" : "https://www.youtube.com/watch?v=IlEsdxuD4lY"
    },
    {
        "id" : 58,
        "question" : "Construct Binary Tree from Preorder and Inorder Traversal",
        "levels" : "Medium",
        "tools" : "Recursion",
        "algorithm" : ["Return null if either preorder list or inorder list is null.",
        "Set the first element of preorder is the root.",
        "Find the index of root in inorder list.",
        "Put the left part of both preorder list and inorder list as the parameters of the recursive call and set it into root left.",
        "Put the right part of both preorder list and inorder list as the parameters of the recursive call and set it into root.right.",
        "Return and submit the root."],
        "complexity" : "O(n). Set every element into the tree.",
        "detail" : ["Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree."],
        "input" : "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output" : "[3,9,20,null,null,15,7]",
        "youtube" : "https://youtu.be/ihj4IQGZ2zc"
    },
    {
        "id" : 59,
        "question" : "Container With Most Water",
        "levels" : "Medium",
        "tools" : "Pointers",
        "algorithm" : ["Declare and initialize int result = 0.",
        "Initialize both left and right pointers.",
        "Use while loop with left < right as the condition to calculate the area.",
        "Inside the while loop, area = (right - left) * min(height[left], height[right]).",
        "And only update result if area is greater than result.",
        "Update the smaller pointer between left and right for the next loop.",
        "Return and submit the result."],
        "complexity" : "O(n). Only iterate every element once.",
        "detail" : ["You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).",
        "",
        "Find two lines that together with the x-axis form a container, such that the container contains the most water.",
        "",
        "Return the maximum amount of water a container can store.",
        "",
        "Notice that you may not slant the container."],
        "input" : "height = [1,8,6,2,5,4,8,3,7]",
        "output" : "49",
        "youtube" : "https://youtu.be/UuiTKBwPgAo"
    },
    {
        "id" : 60,
        "question" : "Letter Combinations of a Phone Number",
        "levels" : "Medium",
        "tools" : "Dictionary, Back Track Recursion",
        "algorithm" : ["Create an empty list to store the final result.",
        "Declare and inicialize a dictionary the char digit as the key and the string letters as the value.",
        "Make a helper function with int i (represent the current index of digits) and String curr (build and represent the one possible string) as the parameters for backtracking use.",
        "Inside the helper function, append curr into result and return the result list if the length of curr == the length of digits.",
        "Store the string value using digits[i] as the key to find the value from the dictionary.",
        "Use for loop to iterate every characters of the string value and make a recursive call for every characters.",
        "The parameter curr in the recursive call is curr + value[j].",
        "Return the result list.",
        "Back to main function, call the helper function if digits is not an empty string.",
        "Return and submit the result list."],
        "complexity" : "O(4^n).\\nThe most digits that a single number can represent is 4.\\n The most output we might get is 4^n.",
        "detail" : ["Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.",
        "",
        "A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters."],
        "input" : "digits = '23'",
        "output" : "['ad','ae','af','bd','be','bf','cd','ce','cf']",
        "youtube" : "https://youtu.be/0snEunUacZY"
    },
    {
        "id" : 61,
        "question" : "Word Search",
        "levels" : "Medium",
        "tools" : "DFS, Resursion",
        "algorithm" : ["Store the number of rows and columns into 2 variables.",
        "Create an ArrayList to store the path where the data inside is a tuple of the coordinate.",
        "Use a nested loop to run the board and return true if the return value of dfs() function is true. Otherwise, return false outside the nested loop.",
        "The dfs() function has 3 parameters, current row, current column, and current index of the word.",
        "Inside the dfs() function, return true if index = the length of the word, which means we found the path that match the string word in the board.",
        "Return false if:",
        ["Either current row or column is out of bound.",
        "The current character is not the character of the word.",
        "The path has already visited."],
        "Add current coordinate into the path.",
        "Call dfs() function recursively to go 4 different positions and store its return value into check variable.",
        "Remove current coordinate from the path.",
        "Return check variable."],
        "complexity" : "O(row * column * 4^n).\\nVisit every slot of the board.\\nFour different directions.\\nAt least need to call dfs() n times where n = the number of word.",
        "detail" : ["Given an m x n grid of characters board and a string word, return true if word exists in the grid.",
        "",
        "The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once."],
        "input" : "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'",
        "output" : "true",
        "youtube" : "https://www.youtube.com/watch?v=m9TrOL1ETxI"
    },
    {
        "id" : 62,
        "question" : "Find All Anagrams in a String",
        "levels" : "Medium",
        "tools" : "Dictionary, List",
        "algorithm" : ["Create 2 HashMaps. One is collect all key-value pairs of the string p, called pCount, and the other one is the key-value pairs of the string s, called sCount.",
        "Declare an ArrayList result for the final answer.",
        "Return an empty ArrayList if p.length > s.length.",
        "Use for loop to put key value pair into pCount, and the first p number of s char key-value pair into sCount.",
        "Add 0 into result if pCount = sCount.",
        "Set the left pointer = 0.",
        "Write the other for loop as the right pointer to iterate the s string, start from p.length until s.length.",
        "Append s[right] and remove s[left] to pCount.",
        "If the value of s[left] is 0 in the HashMap, we need to remove the key from the HashMap. The left pointer needs to be minused one after doing so.",
        "Add the left pointer into result if pCount = sCount.",
        "Return and submit result."],
        "complexity" : "O(s)",
        "detail" : ["Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.",
        "",
        "An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once."],
        "input" : "s = 'cbaebabacd', p = 'abc'",
        "output" : "[0,6]",
        "youtube" : "https://youtu.be/G8xtZy0fDKg"
    },
    {
        "id" : 63,
        "question" : "Minimum Height Trees",
        "levels" : "Medium",
        "tools" : "List, Adjacency List (Array & List)",
        "algorithm" : [],
        "complexity" : "",
        "detail" : ["A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.",
        "",
        "Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).",
        "",
        "Return a list of all MHTs' root labels. You can return the answer in any order.",
        "",
        "The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf."],
        "input" : "n = 4, edges = [[1,0],[1,2],[1,3]]",
        "output" : "[1]",
        "youtube" : "https://www.youtube.com/watch?v=Uf5xegYc7XM"
    },
    {
        "id" : 64,
        "question" : "Task Scheduler",
        "levels" : "Medium",
        "tools" : "Dictionary (Using an array instead)",
        "algorithm" : ["Create a char array with length 26 for 26 different English letters.",
        "Run for each loop to count each letters in tasks and store the value to the corresponding slot.",
        "Sort the char array.",
        "Get the most frequent number and store it to a variable by taking the last slot from the char array.",
        "The most idle the answer can have is most frequent number - 1 * n since we do not need idle for the end.",
        "Go through the rest slot and try to fill them into idle. We need to use min between the slot and the most frequent number they do not need a slot for the end as well.",
        "Break the loop if the slot = 0 since the char array is in order.",
        "Return tasks.length + idle if idle is greater than 0. Otherwise, return tasks.length."],
        "complexity" : "O(n).\\nHave to count how many tasks we have.\\nAlways sorting 26 slots, O(1).",
        "detail" : ["Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.",
        "",
        "However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.",
        "",
        "Return the least number of units of times that the CPU will take to finish all the given tasks."],
        "input" : "tasks = ['A','A','A','B','B','B'], n = 2",
        "output" : "8",
        "youtube" : "https://www.youtube.com/watch?v=eGf-26OTI-A"
    },
    {
        "id" : 65,
        "question" : "LRU Cache",
        "levels" : "Medium",
        "tools" : "Dictionary -> Access in O(1), Linked List -> Ordering",
        "algorithm" : [],
        "complexity" : "O(1). For both get() & put() methods using LinkedList head and tail.",
        "detail" : ["Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
        "",
        "Implement the LRUCache class:",
        "",
        ["LRUCache(int capacity) Initialize the LRU cache with positive size capacity.",
        "int get(int key) Return the value of the key if the key exists, otherwise return -1.",
        "void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key."],
        "The functions get and put must each run in O(1) average time complexity."],
        "input" : [["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"],
            [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]],
        "output" : "[null, null, null, 1, null, -1, null, -1, 3, 4]",
        "youtube" : "https://www.youtube.com/watch?v=NDpwj0VWz1U"
    },
    {
        "id" : 66,
        "question" : "Kth Smallest Element in a BST",
        "levels" : "Medium",
        "tools" : "",
        "algorithm" : [],
        "complexity" : "",
        "detail" : ["Given the root of a binary search tree, and an integer k, return the k^th smallest value (1-indexed) of all the values of the nodes in the tree."],
        "input" : "root = [3,1,4,null,2], k = 1",
        "output" : "1",
        "youtube" : "https://youtu.be/5LUXSvjmGCw"
    }
]